<%inherit file="TutorialSample.html"/>
<%block name="editor_init">
setcode('f(x := cplusplus.std.ostream.lvalue) := void {\n    x << "Hello, World!";\n}\nMain() {\n    f(cplusplus.std.cout);\n}', '#include <iostream>\n')
</%block>
<%block name="editor_head">
<script type="text/javascript">
function generic_example() {
    setcode('f(x) {\n    x.f();\n}\nMain() {\n    f(cplusplus.first);\n    f(cplusplus.second());\n    f(cplusplus.third());\n}', '#include <iostream>\n#include <string>\nnamespace first { void f() { std::cout << "Hello"; } }\nstruct second { static void f() { std::cout << ", "; } }\nstruct third { void f() { std::cout << "World!"; } }')
}
function inference_example() {
    setcode(
        'f(x := bool) {\n    if (x) return cplusplus.boost.make_optional("Hello, World!");\n    return cplusplus.boost.none;\n}\nMain() {\n    if (result := f(true))\n        cplusplus.std.cout << "Hello, World!";\n}',
        '#include <iostream>\n#include <boost/optional.hpp>'
    );
}
</script>
</%block>
<%block name="samples">
<li><a href="#" onclick="inference_example()">Return Type Inference</a></li>
<li><a href="#" onclick="generic_example()">Duck-typed arguments</a></li>
</%block>
<div class="row">
    <div class="col-md-12">
        <p>Functions in Wide are defined by a simple identifier, arguments, then body. The return type may be left off for an inferred return type, as in Main, or it may be made explicit, like f. Return type inference in Wide is 
        substantially more useful than it's C++ counterpart, because Wide does not have the problem of not being able to infer return types of functions in other translation units. In addition, Wide can infer return types in 
        recursive functions in a much wider range of circumstances, and can infer the return type when the types are related instead of identical. Most Wide functions that do not have to adhere to a contract should not require an 
        explicit return type.</p>
        <p>Main can have a return type of void, in which case it implicitly returns 0 to the operating system, or it can return int.</p>
        <p>Wide also has duck-typed functions. You can create a duck-typed argument by simply leaving off the type initializer for that argument. Wide will accept absolutely anything for these arguments. Using <code>.</code> to 
        access members of namespaces as well as objects is not simply a case of syntax re-use- namespace objects are values too and respond to the same member access semantics.</p>   
        <p>Wide currently has no facilities for named parameters, but they are planned.</p>        
	</div>
</div>
