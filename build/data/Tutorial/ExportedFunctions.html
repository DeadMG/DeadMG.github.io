<%inherit file="TutorialSample.html"/>
<%block name="editor_head">
<script type="text/javascript">
function resolve_example() {
    setcode(
        'using t := cplusplus.t;\n[export := t().f.resolve(t.lvalue)]\nf(this := t.lvalue) {\n    return "Hello,";\n}\n[export := t().f.resolve(t.rvalue)]\nf(this := t.lvalue) {\n    return " World!";\n}\nMain() {\n   cplusplus.g();\n}', 
        '#include <iostream>\nstruct t {\n    const char* f() &;\n    const char* f() &&;\n};\nvoid g() {\n    t obj;\n    std::cout << obj.f() << t().f();\n}'
    )
}
function destructor_example() {
    setcode(
        '[export := cplusplus.t.destructor]\n~type() {\n    std.cout << "Hello, World!";\n}\nMain() {\n    cplusplus.g();\n}', 
        'struct t { ~t(); };\nvoid g() {\n    t obj;\n}'
    )
}
</script>
</%block>
<%block name="samples">
<li><a href="#" onclick="resolve_example()">Member sets</a></li>
<li><a href="#" onclick="destructor_example()">Destructor</a></li>
</%block>
<%block name="editor_init">
    setcode('[export := cplusplus.f]\nf() {\n    return "Hello, World!";\n}\nMain() {\n    cplusplus.g();\n}', '#include <iostream>\nconst char* f();\nvoid g() {\n    std::cout << f();\n}')
</%block>
<div class="row">
    <div class="col-md-12">
        <p>A core tenet of Wide's interoperation strategy is that you should be able to migrate existing C++ codebases to Wide one piece at a time. This implies implementing C++ functions from Wide. To do this we introduce the 
        export attribute. Currently only certain special attributes are supported, not generic user-defined attributes. The export attribute defines that a Wide function should be exported as implementing a given C++ function. The
        detail of mangled names is handled automatically by the implementation and not exposed to the user. The Wide export mechanism permits exporting one Wide function as an arbitrarily large number of C++ functions.</p>
        <p>For functions which stand alone, a simple reference is enough. For functions which are members of an overload set, we introduce the "resolve" member. The result of calling "resolve" with a list of types is an overload 
        set carrying the single function that was result of performing overload resolution on that set. For member functions, an explicit "this" is required. For destructors and constructors, always pass lvalue reference as "this".
        Otherwise, you can pass either lvalue or rvalue to respect ref-qualifiers. Exported member functions gain all the rights, like implicit member lookup and private member access, of ordinary member 
        functions.</p>
        <p>Currently, there is no way to refer to a member overload set except by using a value of that object. In addition, the compiler does not properly check the signature of exported functions, so be sure they match.</p>
        <p>Wide does not inherently ban having two functions in a set that would always be ambiguous. This merely makes them uncallable, which is perfectly acceptable if their main purpose is to be exported. Similarly to support
        exporting constructors and destructors, both can be declared at module scope instead of just at member scope. To refer to a constructor or destructor, you can simply use t.constructors or t.destructor. When defining a 
        destructor, Wide automatically adds "this" for you.</p>
	</div>
</div>
