<%inherit file="TutorialSample.html"/>
<%block name="editor_head">
<script type="text/javascript">
function reference_example() {
    setcode('Main() {\n    local := cplusplus.std.string("Fail.", cplusplus.std.allocator(int8)());\n    ref := cplusplus.std.string.lvalue(local);\n    ref = "Hello, World!";\n    cplusplus.std.cout << local;\n}', '#include <iostream>\n#include <string>')
}
</script>
</%block>
<%block name="editor_init">
setcode('Main() {\n    local := "Hello, World!";\n    cplusplus.std.cout << local;\n}', '#include <iostream>')
</%block>
<%block name="samples">
<li><a href="#" onclick="reference_example()">References</a></li>
</%block>
<div class="row">
    <div class="col-md-12">
        <p>Local variables in Wide are introduced with <code>:=</code>. They are always initialized by calling the constructor. The type is deduced from the initializing expression. Wide always deduces a value, like 
        <code>auto</code> in C++, unless you explicitly construct an object of a type, in which case the local will always have that type, even if it's a reference. Local variables in Wide are subject to the same rules of 
        destruction as those in C++. The lifetime of temporaries, however, was expanded to the whole scope.</p>
        <p>The basic notion of references is familiar to you from C++. Instead of a special syntax for denoting a reference, we access a named member of a type. Wide offers both lvalue and rvalue references. Unlike in C++, Wide 
        references are real objects with a size and alignment, so they're more suitable for generic code, and in addition, you can refer to lvalue references (referring to rvalue references is a work in progress). In addition,
        Wide indicates value category exclusively through the type system- so all lvalues are lvalue references.</p>
        <p>Currently, Wide can only resolve implicit conversions between two C++ types, and default arguments for template functions are unfortunately broken.</p>
	</div>
</div>
